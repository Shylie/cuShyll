baseclass Material
- bool Scatter(uint32_t* seed, float t, Vec3 point, Vec3 normal, Ray3& ray, Vec3& attenuation)

subclass Lambertian implements Material
- bool Scatter(uint32_t* seed, float t, Vec3 point, Vec3 normal, Ray3& ray, Vec3& attenuation)
{
	ray = Ray3(point, normal + Vec3::RandomUnitVector(seed));
	attenuation = albedo;
	return true;
}
= Vec3 albedo

subclass Metal implements Material
- bool Scatter(uint32_t* seed, float t, Vec3 point, Vec3 normal, Ray3& ray, Vec3& attenuation)
{
	ray = Ray3(point, ray.Direction() - 2.0f * Vec3::Dot(ray.Direction(), normal) * normal);
	attenuation = albedo;
	return Vec3::Dot(ray.Direction(), normal) > 0.0f;
}
= Vec3 albedo

subclass Generic implements Material
- bool Scatter(uint32_t* seed, float t, Vec3 point, Vec3 normal, Ray3& ray, Vec3& attenuation)
{
	if (randLCG(seed) < reflectivity)
	{
		attenuation = albedo;
		Vec3 reflected = ray.Direction() - 2.0f * Vec3::Dot(ray.Direction(), normal) * normal;
		float r = reflected.Length();
		float theta = acos(reflected.z / r);
		float phi = atan2(reflected.y, reflected.x);
		theta += 3.1415926f * 0.5f * (2.0f * randLCG(seed) - 1.0f) * gloss;
		phi += 3.1415926f * 0.5f * (2.0f * randLCG(seed) - 1.0f) * gloss;
		ray = Ray3(point, Vec3(r * sin(theta) * cos(phi), r * sin(theta) * sin(phi), r * cos(theta)));
		return Vec3::Dot(ray.Direction(), normal) > 0.0f;
	}
	else
	{
		attenuation = albedo * (1.0f - reflectivity);
		float r = normal.Length();
		float theta = acos(normal.z / r);
		float phi = atan2(normal.y, normal.x);
		theta += 3.1415926f * 0.5f * (2.0f * randLCG(seed) - 1.0f) * gloss;
		phi += 3.1415926f * 0.5f * (2.0f * randLCG(seed) - 1.0f) * gloss;
		ray = Ray3(point, Vec3(r * sin(theta) * cos(phi), r * sin(theta) * sin(phi), r * cos(theta)));
		return true;
	}
}
= Vec3 albedo
= float reflectivity
= float gloss

baseclass Hittable
- bool Hit(Ray3& ray, float tMin, float tMax, float& t, Vec3& point, Vec3& normal, Material*& mat)

subclass Sphere implements Hittable
- bool Hit(Ray3& ray, float tMin, float tMax, float& t, Vec3& point, Vec3& normal, Material*& mat)
{
	Vec3 oc = ray.Origin() - center;
	float b = Vec3::Dot(oc, ray.Direction());
	float c = oc.LengthSquared() - radius * radius;
	float discriminant = b * b - c;
	if (discriminant > 0.0f)
	{
		float sqrtDiscriminant = sqrt(discriminant);
		float temp = (-b - sqrtDiscriminant);
		if (temp > tMin && temp < tMax)
		{
			t = temp;
			point = ray.PointAt(temp);
			normal = (point - center) / radius;
			mat = material;
			return true;
		}
		temp = -b + sqrtDiscriminant;
		if (temp > tMin && temp < tMax)
		{
			t = temp;
			point = ray.PointAt(temp);
			normal = (point - center) / radius;
			mat = material;
			return true;
		}
	}
	return false;
}
= Vec3 center
= float radius
= Material* material